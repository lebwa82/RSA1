lДиспетчер ввода вывода (часть операционной системы)
Когда процессу нужно обратиться к диску, он обращается к диспетчеру ввода-вывода, и говорит что ему нужно прочитать данные. Диспетчер ставит запрос в очередь. Если диск свободен, то диспетчер сразу выполнит запрос. Если несколько процессов требуют прочитать подряд идущие сектора, то он прочитает данные для одного запроса, и для второго сразу, потому что так быстрее.  Те диспетчер ввода-вывода – это механизм оптимизации работы процессов с диском.

Есть дисковое пространство. Процессы не могут к нему напрямую обращаться. Это пространство нужно разделить между процессами. Поэтому на диск мы накладываем структуру данных, которая называется файловая система. Она состоит из служебной инфы и области данных: содержит информацию которая предназначена для процессов. Она разбита на кусочки, каждый кусочек для своего процесса, кусочек называется файл.
Для того чтобы связать файл с процессом нужно выполнить операцию, называемую открыть файл. 
Один процесс может открыть несколько файлов. 
Дискриптор процесса хранит информацию, о состоянии процесса в момент прерывания.
Таблица открытых файлов 
Индекс – небольшое целое число, номер потока ввода вывода
Каждому открытому файлу соответствует свой поток ввода вывода
Номер – индекс в таблице дискрипторов
Каждый процесс может делать с файлов: 
1)Прочитать данные с файла. Будут читать с того места, где прекратилось чтение в прошлый раз
2)Записать данные
3)Установить метку на нужное место
Все происходит в терминах байтов

Чтобы это было возможно в дискрипторе должна быть еще информация о текущей позиции чтения, и о текущей позиции записи в данном файле.
Файловая система позволяет разделить данные между процессами, таким образом данные принадлежащие одному процессу не смешиваются с данными другого процесса.
Таблица открытых файлов находится в дискрипторе процессов.


Что значит многопользовательская операционная система?
Нужно уметь защищать данные принадлежащие одному пользователю от данных другого пользователя. 
Для оперативной памяти: нужно сделать чтобы начало всех виртуальных страниц были разными.
Для диска: для каждого файла есть понятие: атрибуты файлов.
Атрибуты файлов
1) Его длина 
2) UID файла. Каждому пользователя соответствует число, которое называется УИД. UID файла определяет какому пользователя принадлежит файл
3) GID целое число которое определяет группу файлов
4) Права доступа файла: каким пользователям можно читать и писать файлы. 
Для исполняемых файлов также описано кто может выполнять файл а кто нет
Все пользователя делятся на:
1) Владелец: когда уид файла совпадает с пользовательским уид 
2) Гид (члены группы) когда пользователь входить в группу, гид которой совпадает с гид файла
3) Все остальные
Для каждой группы можно разрешить: читать, писать, исполнять
Права доступа: Для каждой группы восьмиричная цифра, потому что для каждой группы три бита (разрешено ли чтение, запись, исполнение), а 2^3=8
641 означает что: владелец может читать и писать, группа может только читать, а остальные могут только исполнять

Процесс INIT – корень всех процессов
Каждый процесс имеет атрибуты:
1) номер PID (process indeficator) 0-2^16-1, каждый следующий процесс имеет номер на единицу больше. Когда все 65000 процессов созданы, отсчет снова начнется с нуля. Поэтому может так получиться, что два процесса иметь один номер, но они никогда не будут работать одновременно.
ИНИТ имеет номер 1.
2) PPID – PID родителя (parent PID). 
3) UID – определяет какому пользователя принадлежит процесс (от имени какого пользователя будет выполняться)
4) GID – какой группой выполняется процесс. Может быть несколько гидов, потому что один процесс может работать с несколькими файлами, и для каждого файла нужен свой гид. (а у файла может быть только один гид). 
5) Таблица открытых файлов (таблица файловых дискрипторов)

Наследование атрибутов процесса
Когда один процесс создает другой, почти все атрибуты (3-5) родителя наследуются потомков, те потомок получает копию. Если родитель изменит атрибуты, то на потомка это не повлияет.
Если потомок наследовал открытый файл, то позиции чтения и записи остаются синхронизированными для родительского и дочернего процесса

Если родитель и потомок независимо открыли файл, то позиции не синхронизируются.

Суперпользователь – пользователь с уид равным нулю. Может читать и писать любой файл. Это администратор, игнорирует права доступа.

Для каждого устройства существует файл (файл устройств), который позволяет обратиться к устройству, минуя файловую систему. Те чтобы напечатать что-то на принтере, нужно просто что-то записать в файл принтера.

Команда ls –l
Echo hello >/dev/pts/5 - записать hello в файл dev/pts/5
Когда пользователь входит, ему открывается три потока: ввода (0), вывода (1), стандартных ошибок (2)

Процесс Шелла – особый класс процесса
Программы которые работают с этим процессом кончаются на sh bash csh
Они читают строчку ввода и делит на слова. 
Первое слово – имя команды, тот файл который необходимо исполнить, а остальное параметры команды

Шелл выдает приглашение на экран (для того чтобы показать кому предназначены данные), а потом читает одну строку, до символа конца строки
Шелл создает новый исполняемый файл, потом создает отдельный процесс, загружает в него исполняемый файл и ждет, потом делает вывод и ждет нового ввода.
Шелл останавливается когда встречает exit
Основная задача Шелла – запуск других процессов
Процесс логин Шелл первая программа которая запускается при входе в ОС


Типы файлов
1) Файлы с данными на диске (исходный код программы)
2) Файлы устройств
3) Каталоги, папка, директория – это все одно и то же, содержит имена других файлов и информацию об их расположении
Корневой каталог, информация о его расположении находится внутри системной инфы файловой системы.
Внутри каталога могут находится файлы разных типов.
Вся последовательность каталогов от корневого – полный путь к файлу, начинается с /
Путь не начинающийся с / называется относительным, те идет от текущей директории
Команда pwd выводит текущую директорию
Команда cd (change directory) меняет текущую директорию
Рабочие директории у процессов


Концепт swd
Для преобразования имени пользователя в уид и обратно (аналогично для группы) есть файл swd
Каждая строчка этого файла соответствует пользователю
Строчка имеет 7 полей
1) Имя ползователя 
2) Пароль, в современном под пароль выделен отдельный файл, к которому имеет доступ только суперпользователь
3) Уид
4) Гид 
5)комментарий –информация о пользователе  (ФИО, телефон и т.д.)
6)Домашняя директория – рабочая директория для логин Шелла
7) какая программа будет загружена логин Шеллом
В первой строчке описывается суперпользователь, его имя обычно rude
Команда sudo выполнение от имени суперпользователя


 Echo hello – выведет на консоль
Echo hello >file – запишет в файл
Команда cat – стандартная команда > ввод,  < вывод

Команда man показывает руководство
Только процессы могут что-то делать с файлами, пользователь может только печатать на клавиатуре и контролировать вывод.
Чтобы пользователь мог запускать процессы, есть специальный процесс шелл. Которые читает входную программу и запускает процессы.
# строчка комментария
Переменные в шелл: строка
Как только переменную используем – значит она объявлена, если не задано значения, следовательно значения пустая строка
X=abc переменной х присвоили значение abc, причем кавычки как в других языках писать не нужно
Пробел является разделителем параметров, поэтому нельзя писать x = abc с пробелами
Шелл не умеет складывать и вычитать, а может только подставлять
Подстановка переменной
$ значит должна быть операция подстановка переменной
X=abc 
Echo $x следовательно распечатается abc
А если написать echo abc$x, то напечатается abcabc
Если написать abc$xabc, то шелл увидит что переменной xabc нету, подставит вместо нее пустую строку, и напичатает abc
Echo abc${x}abc выведет abc – фигурные скобки точно определяют границы переменной

Подстановка домашней директории
Если после тильды идет идет имя пользователя то будет подставлено имя домашней дирректории пользователя чье имя указано
Если после тильды идет слеш, то просто будет подставлено имя домашней директории текущего пользователя

Подстановка стандартного вывода
Если в строке есть ` подстрока `, то  что в `` будет выполнено как команда, и все символы новой строки будут заменены на пробелы 

Подстановка файловых шаблонов (тоже не понятно)
Выполняется после первых трех подстановок
Те ? это любой один символов
Если * то любое количество любых символов или пустой строке
[1-9] любой символ из промежутка
Если [!1-5] любой символ не из промежутка
Минус смотрит только соседние символы

Скрытые файлы, те которые начинаются с точки
Скрытые файлы не подставляются в файловые шаблоны. Исключение: если сам шаблон начинается с точки, то скрытые файлы будут показаны

Echo */* все имена файлов не начинающихся с точки во всех директориях не начинающихся с точки


Экранирование символов те нам нужно напечатать спец символ например $x
Как это сделать:
1)Echo \$x выведет $x
Если написать echo \\$x то один слеш экранирует второй и потом выводится х
2) echo ‘$x’ (одинарные прямые кавычки) выведет $x
3) двойные кавычки экранируют все кроме $ и обратных кавычек
X=a*c
Echo “$x” выведет a*c тк “” экранируют *.


Редактор vi, nano, mcedit
Первая строчка должна напечатать Hello world!!!
Вторая: I am имя пользователя – находится в переменной user
Третья: Today текущая дата – выводится командой date
Мы можем использовать echo и date 


Виды параметров
Позиционные параметры: обычно имена файлов, определяется позицией в командной строке
Ключевые параметры: состоят из одной буквы и начинаются с минуса, определяются не местом а значением, ключевые параметры команды всегда фиксированы
Ключевые параметры можно слеплять, те вместо –a –l можно писать –al или –la
Если мы хотим написать параметр с минусом, и чтобы он воспринимался как позиционный, то его следует писать после первого позиционного параметра
Все что идет после двух минусов подряд (--) воспринимается как позиционные параметры

Длинные ключевые параметры – это не один символ в строка, перед которой идет два знака минус 

Команда ls и ее ключи: 
Если поставить позиционным параметром имя файла, то она выведет информацию о нем
Если директорию, то выведет файлы в директории
-l выводит подробную информацию
Если поставить ls –l файл то сначала тип файла, потом разрешения, число жестких ссылок, имя владельца файла, имя группы которой принадлежит файл, дата создания, имя файла к которому относится данная строка
Типы файлов:
Обычные файла (знак минус)
Директория d
Символические ссылки l
Файлы устройств начинаются с “с” или “b”
Socket - s
Именованные каналы – p

Продолжаем ключи ls
-d
-f будет выдаваться тип файлового объекта, для каждого типа файла рисует специальный символ
Без ключей выдает информацию о рабочей директории
Chown меняет владельца файла (может сделать только суперпользователь), первый позиционный параметр кого сделать владельцем, остальные позиционные имена файловых объектов 
Ключи:
-R если среди позиционных параметров встретим директорию, то поменять владельцев во всех файлах в этой директории, в общем случае рекурсивно обойти все дирректории
Еcли через двоеточие то, указать группу, то файл станет принадлежать этой группе crown root:wheel
charp Если для файла хотим поменять только группу 
chmod меняет права доступа, 755 новые права доступа, либо в виде символов 
u вдаделец
g владелец
o остальные
Вместо oug можно писать a-all
+ хотим добавить право доступа
- убрать
= установить
rwx чтение запись исполнение 
Все это записать в одну строчку
chmod +x file разрешить всем запускать

Права доступа к директориям:
r позволяет узнать информация о каких файлах находятся в директории, но не позволяет получить доступ к ним
x если мы знаем имя файла, то мы можем получить информацию о его расположении
w можно добавлять или удалять файлы, если знаем имя файла

Код возврата:
Процесс 1 создает процесс 2, процесс 2 получает атрибуты процесса 1, они начинают работать параллельно, процесс 2 не может сообщить никакую информацию процессу 1. Но после завершения процесс 2 может сообщить информацию о своем успешном завершении (0) или неуспешном завершении – то будет информацию о том, что пошло не так (информация занимает 1 байт). Обычно успешное завершение – это исполнение всех ожидаемых от процесса действий.
Если в качестве родителя шелл, то код возврата используется как условие (истина -0/ложь - не 0), в зависимости от этого будут разные действия.
В качестве условия может быть несколько команд, в этом случае истинность условия зависит от код возврата последней команды.

В одной строке шелла можно задать несколько команд, их нужно разделить ; что означает дождаться выполнения первой команды и выполнить вторую.

Встроенные и внешние команды:
Type cd показывает тип команды
Любая команда меняющая атрибуты шелла – внутренняя, потому что если бы внешняя команда меняла атрибуты, то никакого влияния на шелл она бы не оказывала
Встроенные команды нужны чтобы менять атрибуты шелла. Если шелл встречает внутреннюю команду, то он не создает отдельный процесс, а выполняет ее сам.



If после нее идет последовательность команд, которая является условием
then если код возврата равен нулю, то будет выполнены аргументы then 
else если не ноль 
может писаться elif
fi заканчивает if, если несколько elf, то должно быть несколько fi
true возвращает 0
false возвращает 1
Восклицательный знак инвертирует код возврата, те меняет 0 на 1, а ненулевое число на ноль


While условие идет до слова do, тело цикла заканчивается словом done
Команды break, continue могут иметь параметров: на сколько ступеней вложенности нужно подняться и закончить или продолжить цикл

Команда test
Условия для файлов:
test –r file доступен ли файл для чтения
test –w file доступен ли файл для записи
test –s file файл ненулевой длины
test –b file является ли блочным устройством, аналогично для других ключей
test –e file существует такой объект или нет
Условия для строк:
test –n string ненулевая ли строка (те истина если строка ненулевая)
test –z string нулевая ли строка (те истина если строка нулевая)
test string1 = string2 равные ли строки
test string1 /> string2 сравнивает строки
Сравнения чисел (работает только для целых чисел):
test 4 –eq 5 не равны ли числа
test 4 –le 5 – 4 меньше 5?
test 4 –lt 5 – 4 меньше либо равно 5? Те е нестрогое, t строгое
test 4 –ge 5 – 4 больше 5?


Чтение из стандартного ввода
read a b c – читает одну строчку, первое слово в а, второе в b, а остаток в с, если слов меньше, то остальные переменные будут пустыми строками


Переменная IFS с ее помощью можно задать разделитель между словами, разделителем может быть только один символ. Если разделитель – пробел, то несколько пробелов – тоже разделитель, это работает только для пробела.
IFS=, теперь разделитель не пробел а запятая
IFS=”,;” теперь запятая или точка с запятой разделитель
Если IFS присвоить пустое значение, то read занесет все в первый параметр


Группирование команд можно делать с помощью () или {}, те группа команд будет рассматриваться как одна
(read a; read b; read c; ) <file последовательно прочитает три строчки из файла
read a< file; read b< file; read c< file; три раза прочитает первую строчке
внутри круглых скобочек изменение переменных и атрибутов сохраняется, но только до закрытия скобочек
Чтобы изменения сохранялись на совсем {}
{ - это отдельная команда, после нее нужно писать пробел

Чтобы поместить в буфер обмена (карман) нужно просто выделить, и нажать правую кноаку мыши чтобы вставить

Команды tty печатает местонахождения терминала

Команда stty выведет информацию о текущем терминале 
Ключ –a выедет всю информацию
1) основная информация
2) горячие клавиши которые обрабатывает терминал: например cntrl+c прекратит текущую команду
cntrl+Q прекратит выдачу на экран
cntrl+z текущая программа приостановлена но не прекращена
cntrl+o все что программа будет выводить на терминал будет прекращена до того как еще раз нажму cntrl+o


Файл termcap 1)имена одного и того же терминала идущие через |
2) характеристики терминала
3)какая последовательность посылается в терминал при нажатии определенной клавиши, например клавиши f1
4) какие символы надо послать чтобы сделать определенное действие


Суидные программы
Есть еще 3 права доступа у файлов, которые мы еще не рассматривали (еще 3 бита)
1) Сюид (супер юзер ид): только для исполняемых файлов, если у программы есть сюидный бит, то она не будет наследовать уид и гид, а уид и гид программы будет как у владельца соответствующего файла. Такой уид которые не унаследовался от предка, а взялся от владельца файла называется EUID (еуид) – эффективный уид. Надо понимать что у процесса будет и уид и еуид, для обычной программы уид=еуид. Потомок еуида унаследует еуид предка.
Когда я создаю программу я могу поставить такой бит, а могу не ставить
chmod u+s hello добавили сюид программе hello
Пример программа passwd
Программа su запускает шелл, который будет работать от имени суперпользователя

Эсгидные программы
Так же как суидные только для группы, те бит s ставится для группы
Аналогично EGID – эффективный гид

3) Stickv bit (Стиквбит) для прав доступа к директории 
/tmp директория для временных файлов (доступная все пользователям), и если к какому-то файла не было доступа в течение месяца, то они удаляются
Если есть стикибит – значит удалять файлы может только владелец
Обозначается буквой t

Команда lsattr показывает специфичные для данной системы права доступа


Переменные окружения
При переходе в другой шелл, переменные не наследуются
export x – в новом шелле уже будет х, но если мы в новом шелле поменяем х, то в старом шелле х не поменяется, переменная окружения это атрибут процесса, и наследуется потомком
если export без параметров, то выведутся все переменные окружения
export x=5 – создать переменную окружения и присвоить ей значение 5.
Значения такое переменной можно получить и в программе на языке си:
чтобы получить значения переменной окружения команда getenv, и в агрументах указать имя
чтобы изменить значения переменной –putenv (строка символов имя=значение)
Переменные окружения принято обозначать большими буквами



Настройки шелла задаются в файла  .profile, чтобы его открыть можно написать less .profile
LANG на каком языке будет выводятся сообщения
XUATHORITY файл для авторизации графических приложений
PATH в каких директориях нужно искать исполняемые файлы

Если команда начинается с минуса то это логин шелл, а если без минуса то просто шелл

Команда alias позволяет задать краткое название команде: alias hello=`echo hello`

Чтобы найти исполняемый файл для внешней команды, используется переменная PATH, где перечислены все директории с исполняемыми файлами, в них шелл ищет исполняемый файл соответствующий данной команде.
Выполнив команду шелл запоминает в hash директорию для данной команды. Это делается потому что многие команды выполняются несколько раз, и поэтому быстрее искать в кэше чем в PATH.
Чтобы посмотреть кэш нужно написать hash
Чтобы очистить кэш нужно написать hash –r, это нужно например если мы перенесли команду в другое место, то нам нужно очистить кэш, чтобы шелл искал команду не в кэш, где указано другое место для данной программы, а в новом месте


Команда which печатает исполняемый файл для каждой команды в строке


Специальные переменные шелла: Это возможно тк имя переменная всегда начинается с буквы или нижнего подчеркивания
$ -  пит текущего шелла, специальный атрибут процесса (номер процесса)
? – код возврата последней выполненной команды
У sh может быть кроме первого параметра (имя исполняемого файла) еще несколько
# -  сколько параметров для данной команды указано
0 хранит имя шелловского сприпта
1 хранит имя первого позиционного параметра шелла
2 хранит имя второго позиционного параметра шелла
Минус – с какими ключами вызван шелл
* - строка состоящая из всех параметров программы, разделенные пробелом (первым значением переменной AFS)
@ - аргументы командной строки, причем все аргументы как отдельный параметр. 
Разница будет только если написать в кавычках эти команды 1) вся входная строчка будет записано в один аргумент, 2) все слова будут распознаны как отдельные аргементы.


Команда shift сдвигает все аргументы командной строчки на один влево: первый аргумент пропадает, второй становится первым и тд. Если сдвинуть не удалось то shift возвращает код возврата равный одному. Таким образом можно получить доступ к 10, 11, 12 аргументам sh
Команда shift n -  сдвигает на n аргументов

Команда set задает аргументы логин шеллу
 Echo one two three
Echo $1 – выведет one потому что теперь у логин шелла '

Использование значения IFS в шелловских скриптах, IFS хранит разделяющие символы
Шелл делить строку на слова и воспринимает их как аргументы (разделяющие символы пробелы и табуляция), а при подстановке он разделяет слова используя как разделяющие символы значения IFS 


Цикл for
for i in one two three; do ; done
 for, название переменной, значения которые она будет последовательно принимать, точка с запятой, do, тело цикла (команды через точку с запятой), точка с запятой, donе
если список не задан, но то используются аргументы командной строки
seq 10 -2 1 выводит от 10 до 1, с шагом -2

Дз: написать программу whichx, которая печатает то же что и which
Использовать вложенный цикл for, break, continue
test –x PATHдз
использовать разделители || и &&for


Фоновые задания (background) задания выполняемы на фоне армументов получаемых шеллом, в момент исполнения
Амперсант говорит выполнить следующую команду не дожидаясь пока выполниться предыдущая
Команда jobs показывает фоновые процессы
Команда jobs –l показывает подробную информацию, показывает завершенные процессы, которые мы еще не смотрели  приостановленные процессы
Задания переднего плана (forground) – всегда один, то что мы до этого рассматривали
Команда cntrl + z приостанавливает задание переднего плана
bg %1 продолжить выполнение 1ой приостановленной задачи в фоновом режиме
fg %1 продолжить выполнение 1ой приостановленной задачи в основном режиме
%+ последнее задание
%- предпоследние задание
Wait 1 ждет завершения 1го процесса, если не указать аргументов, то ждет завершения всех процессов



Разделители команд
Мы знаем точка с запятой, новая строка, амперсант
Вертикальная черта (pipe – труба) – если две команды соединены, вывод первой команды записать в ввод правой команды – будем говорить что команды соединены в конвеер. С точки зрения шелла, воспринимаются как одно задание. Работаю параллельно как на конвеере форда.
Command1|command2 эквивалентно command1>tmpfile; tmpfile> command2, только в первом случае работа происходит параллельно, а во втором случае последовательно
Две вертикальные черты || правое выражение будет выполняться только если первое выражение вернуло ложь
Аналогично два амперсанта && правое выражение будет выполняться только если первое выражение вернуло истину

Команды для общения
echo Hello! >dev/ttyp1 написать другому человеку 
Команда write можно написать другому пользователю - это эсгидная программа
В качестве параметра пользователь которому отправить сообщение
Mesg n mesg y запретить и резрешить писать тебе сообщения
Mail имя пользователя– послать сообщение, которое можно прочитать когда пользователь войдет в систему (можно написать любому человеку вообще написав di_par@bk.ru)
Войдя в систему чтобы прочитать сообщение нужно написать mail без параметров



Команды для просмотра файлов
Cat 
More после каждой страницы делает паузу
Less можно просматривать в любом направлении. У этой команды очень много горячих клавиш
/mikle искать подстроку 
N продолжить искать подстроку к началу, n к концу
Всем командам можно передать несколько файлов
Экзешники для more less сейчас совпадают, но когда-то это было не так
Команда man использует для вывода команду less, так что там работают те же горячие клавиши

Head выводит первые 10 строк файла
tail выводить последние 10 строк файла
Им можно указать сколько строк выводить tail -20 например

Команды работы с файлами
Cd
Pwd
Сmp сравнивает файлы, если равны то код возврата 0, если не равны то печатает на каком бите различие удобна для бинарных файлов
Diff для сравнения текстовых файлов, показывает как из исходного файла получить второй
Patch используется для подправления файлов, внося изменения напечатанные diff
Cp file1 file2 копировать файл
Если последний параметр это директория то Cp file1 file2 dir скопировать file1 file2 в dir
Mv аналогична cp, только не копирует а перемещает 
Аналогично если последний параметр директория, то происходит перемещение
Rm удалить файл, нельзя удалить директорию
Rmdir удаляет пустую директорию
Rm –r удалить всю директорию и все файлы в ней
Ls
Mkdir /tmp/abc создать директорию abc в директории tmp
Mkdir –p создать не только директорию но и все директории на ее пути
Touch создает файл


Фильтры
Фильтр это программа читающая данные из стандартного ввода, обрабатывает их и выводит результат в стандартный вывод
Cat без параметров – пустой фильтр
Fgrep вытащить только те строки, в которых есть указанное слово
Fgrep читает из стандартного ввода и выводит только те строчки в которых есть слово указанное первым позиционным параметром

Sort сортирует строки. Cntrl +D – сорт прочитает конец файла
-r в обратном порядке 
-n цифровая сортировка, без этого ключа по первой букве

Wc считает сколько символов слов и строк.
Tr a x заменить все вхождения a на x
Tr abc xyz заменить все вхождения a на x, b на y, c на z
Tr abc x заменить любой из abc на x
Tr –s если в результате замены получились повторяющиеся символы, ужать их до одного
Tr –c любой из символов не первого набора параметров заменить на символ второго параметра
Tr a-f x (a-f означает все символы в промежутке a-f)
Tr –f удалить все символы из указанные в позиционном параметре

Uniq если несколько строк встречаются несколько раз подряд, она будет выводить эту строку только один раз
Unic –c будет печатать сколько раз эта строчка встретилась
С помощью фильтров можно создавать сложные команды, объединяя их в конвеер
Ls –F fgrep / |wc –l считает сколько поддиректорий в этой директории


Case str in 
Файловые шаблоны) заканчиваются )
Команды;; заканчиваются ;;
Esac
Вместо default написать в файловом шаблоне писать *
Может выполниться только один case

ДЗ
Если в имени команды встречается / то шелл не просматривает path а считает что имя команды и имя файла совпадает и просто идет по пути 
1)Переделать задачу whichx если в имени команды whichx присутствует слеш, то не искать в path пользоваться кейсом
2) Мы не можем использовать в качестве входного и выходного файла один и тот же
Написать команду owerwrite. Она должна записать результат работы фильтра в временный файл, и после окончания работы фильтра должна скопировать результат работы фильтра в тот файл который указан в качестве ее параметра, после чего удалить временный файл

/tmp директория для временных файлов
Чтобы создать файл с уникальным именем можно использовать $ который хранит уид процесса
 Команда mktemp создает файл  по шаблону over 6 букв х, получившееся имя подается в стандартный вывод


Команды поиска файлов
Find имя директории, (которая будет использоваться как корень дерева), условие (если оно выполнено то будет напечатано имя файла)
Условия: 
-name `*c` в имени есть символ с
-type тип файлового объекта
-size +10 размер больше 10 байт
-size -1024 меньше одного килобайта
Xargs читает строчки со стандартного ввода и добавляет их в аргумент команде которая идет после xargs (которая является параметром xargs). Обычно используется для команд с большим выводом, например find.

Locate bash выводит все файлы в который встречается файл bash. Не ищет на диске, а в базе данных, где перечислены все файлы в системе. База данных обновляется каждую ночь. Может потребоваться обновить базу данных. В базе искать гораздо быстрее.


Отладка шелловских скриптов
Самый простой способ echo
Ключ –x будет напечатана команда после подстановок. Перед командой будет написано + проблем
Это строка (+), которая печатается перед подстановкой задается переменной ps4
-v показывает строку которую шелл прочитал из файла

!125 выполнит 125ую команду из истории команд
!! выполнит предыдущую команду


Файловая система
Раньше использовались ATA диски, их может быть максимум 4 штуки, файлы устройств соответвующие им начинаются с ad[0-3] (если сата диск то sd), которые позволяют обратиться напрямую диску.
Команда fdisk позволяет разбить диск на разделы. Метки разбивают диск на еще более мелкие кусочки.

Диск целиком делится на части: разделы (слайса) в начале каждого раздела стоит метка: задает области раздела (партишены). Для каждого слайса и партишена есть файл устройств те для ОС они выглядят как отдельный диск. Партишен с именем с – весь слайс целиком. Партишены могут пересекаться. 
Обычно границы партишенов и границы слайсов стараются синхронизировать с границами цилиндра, чтобы головка быстрее работала с диском.
Купили новый диск:
fdisk создать табилицу слайсов
Disklable создать партишены (также используется для чтения и записи на партишен)
newfs  или mkfs (имя файла  устройств) - создать файловую систему. Затем ее нужно присоединить к ОС.
Mount (файл устройств на котором находится файловая системы) (имя директории к которой эта файловая система должна быть присоединена) - присоединить   
Если вызвать без параметров – покажет какие файлы устройств к какой файловом системе присоединены
Файл /etc/fstab показывает для каждой файловой системы к какой директории примонтировать при запуске ОС
По колонкам:
Имя файла устройств, к какой директории должна быть примонтирована, тип файловой системы, опции монтирования (rw данная система монтируется на чтение и запись), дамп (в каком порядке должны делаться резервные копии файловых систем), пасс (в каком порядке проверять на целостность). 
Напоминание: Своп – место на диске, для хранения элементов оперативной памяти, когда ее не хватает.
Fsck проверяет целостность файловом системы
Если команда найдет файлы которой нет ни на одном диске, она поместит это файл в директорию /lost+found

Рассматриваем файловые системы
Служебная область состоит из двух частей:
Суперблок хранит информацию о диске: его размер, размер инодов, и т.д. и занимает очень мало места, если его разрушить, то доступ к файловом системе будет невозможен, поэтому его хранят в нескольких вариантах
Область инодов: массис струкур, каждая структура соответствует одному файлы на диске, сама структура называется инодом, а индекс в массиве называется номером инода.
Инод хранит длину файла, права доступа, кому принадлежит, на каких секторах диска находится файл. Те вся информация кроме имени файла. Имя файла хранится в директории.
В директории хранится имя файла и номер инода.
В одной директории может хранится один и тот же файл, под разными именами. Или в разных директориях может хранится указатель на один и тот же файл.
Про такие файлы говорят, что они связаны жесткой ссылкой.
Для каждого файла есть счетчик жестких ссылок, которая хранится в иноде. Когда мы используем rm уменьшает на 1 число жестких ссылок. Когда число жестких ссылок становится 0, место на диске освобождается.
Ln abc def создать жесткую ссылку  между abc и def. Те abc и def один и тот же файл.
Ls –il показать номер инода в первой колонке (у этих файлов один и тот же инод). В третьей колонке число жестких ссылок.
Find –inum 123 найти файл с инодом 123

Любой пользователь может создавать жесткие ссылки на файлы, кроме директорий. Жесткие ссылки на директории может создавать только sudo.

Когда мы создаем директорию, на нее всегда создается две жесткие ссылки с именами: точка (текущая директория) и две точки (родительская директория).
Точка: ссылка на директорию в которой находится эта директория. Имеет такой же инод, как и директория в которой она находится.
Две точки: такой же инод как и директория в которой находится директория в которой содержится две точки.
Для корневой директории номер инода всегда 2. Родительская директория корневой она сама.

Нормальное объяснение:
поясняю: точка - текущая директория, две точки - родительская директория. то есть cd . ничего не сделаета cd .. сделает то же самое, что в винде делает кнопка вверх: то есть перейдёт в родительскую.
С помощью директории две точки можно задать имя файла относительно произвольной директории. Те вместо абсолютного имени файла, можно задавать имя файла относительно данной директории (относительные имена файлов не начинаются с слеша). 
Cd .. перейти в родительскую папку. Те в папке есть есть дочерняя папка, которая есть указатель на родительскую директорию. В корневой .. указывает на саму себя.
/ корневая директория
Cd . остаться на месте. Те в папке есть поддиректория которая указывает на эту самую директорию. 
Cd ~ войти в домашнюю директорию
Рабочая директория – та в которой я сейчас нахожусь

Число жестких ссылок на директорию = число поддиректорий + 2 


Мягкие ссылки – специальный файловых объект внутри которого содержится имя файла.
В выдаче ls обозначаются буквой L.
Мягкие ссылки имеют только инод, и в области данных не занимают места.
Мягкие могут ссылаться на файл, которого не существует, могут ссылаться на файл из другой файловой системы, удаление мягкой ссылки не приводит к удалению файла. 
Мягкие ссылки могут указывать на директории. В мягких ссылках есть файл, и файловый объект на который ссылка указывает 
Ln –s создает мягкую ссылку. 
Readlink abc показывает на что ссылается файл abc


Подробнее про файлы устройств
Когда мы пишем в этот файл – мы пишем в это устройство.
Устройства бывают: 
Символьные последовательное чтение или запись
Блочные устройства: можно читать и писать данные только блока
В современном мире границы стираются, но в линуксе символьные устройства еще сохранились
Если мы вызовем ls то для символьного устройства будет с в первой позиции, а для блочного b
Вместо длины файла, ls -l для файла устройств пишет два числа:
Главный номер (первый) - номер, соответствующий типу файла устройств, который определяет драйвер
Минорный номер – для выделения конкретного устройства обрабатываемой данным драйвером

Если устройство может присоединятся к компьютеру прямо во время работы (например флешка) такие устройства имеют главный номер равный нулю.


Сигналы
Сигналы - механизм выполнения неожиданных для программы действий (как прерывания в процессоре). Сигнал - это атрибут процесса и наследуется от родителя к потомку. 
Но обработка прерывания это чисто аппаратная штука, происходит в ядре ОС.
Мы сообщаем ОС в какой момент вызвать какой обработчик сигнала, реализуются чисто програмv но. 
У каждого типа сигнала свой номер, для каждого типа сигнала свой обработчик.
Кроме номера сигнала, у каждого сигнала есть еще имя (всегда пишется большими буквами), которое начинается с SIG*
Обработка сигнала может быть:
1)По умолчанию
2)Программа может проигнорировать
3)Вызвать тот обработчик, который задала сама программа
Те приходит сигнал 1) смотрим есть ли обработчик, если он есть то идем туда, если его нету, смотрит нужно ли его игнорировать, если не нужно игнорировать то выполнить действие по умолчанию

Действия по умолчанию бывают:
1)Разрешите завершить программа
2)Завершиться с дампом памяти
3)Игнорировать
4)Приостановить выполнение процесса

Есть два особых сигнала с номерами 9 (sigter – завершить процесс) и 17 (sigstop – приостановить действие процесса) – для них всегда выполняются действия по умолчанию. 
Если для процессу использует обработку по умолчанию, то ребенок то будет использовать тоже по умолчанию. Если у родителя есть обработчик сигнала,  то ребенок по умолчанию. Если родитель игнорирует, то ребенок тоже игнорирует. 


Управляющий терминал – атрибут процесса, назначается логин шеллу, когда пользователь входит в ОС. Все потомки логин шелла образуют отдельный сеанс. Управляющий терминал - атрибут процесса данного сеанса. При завершении логин шелла: сигнал SIGHUB имеющий номер 1 (завершить процесс) подастся всем потомкам логин шелла. 
Man signal – описание сигналов
SIGINT подается когда мы нажимаем cntrl +c – завершить процесс
SIGALRM сигнал-будильник


Обработчик сигналов в шелле – последовательность команд
Команда trap ‘echo hello' 2 (или SIGINT) – задает обработчик сигнала. Те слово hello выведется только когда мы нажмем cntrl + c
Trap без параметров выдает текущие обработчики сигналов
Trap ‘ ‘ 2 – игнорировать сигнал 
Чтобы вернуть обработку по умолчанию надо написать trap – 2 (здесь два параметра)
Чтобы послать сигнал другому процесс нужна команда kill (номер сигнала который хотим послать – перед номером процесса нужно написать минус) (какому процессу мы хотим послать сигнал)
X=5
Trap ‘echo $x’ 2 – теперь при нажатии cntrl + c будет печататься 5

Trap ‘echo $x’ 2
X=7
cntrl + c
Будет напечатано 7, потому что подстановка будет выполнена после строчки x=7, это специфика одинарных кавычек



Trap “echo $x” 2
X=7
cntrl + c
Будет напечатано 5 тк подстановка была выполнена до строчки x=7, это специфика двойных кавычек
Команда nohup (какая-то команда) – выполняет программу указанную в параметре (запускает ее в фоновом режиме), но продолжает даже при завершении сеанса терминала (должна проигнорировать сигнал SIGHUB), и если человек снова войдет в терминал, то вывод будет идти в фал nohup.out. Однако если стандартный вывод команды это файл, то данные и будут идти в этот файл.
В любом случае перенаправить вывод в nohup.out
Чтобы проверить является ли стандартный вывод терминалом использовать test –t 1

Если несколько процессов объединены | пайпом (конвеер), и если мы посылаем сигнал одному процессу, то мы посылаем сигнал сразу всем процесс 


Дз 
1) в программе оверайт
если пользователь сделает cntrl + c все временные файлы удалялись
Пока идет копирование из временного файла в исходный: сигналы нужно игнорировать
2) Написать эмуляцию программы no nohup  назвать ее execbg



Пакетные задания
Запускаются с помощью команды at 13:45 следующие команды запустятся в это время. 
atq список текущих заданий
Задания могут запускаться и позже, зависит от настроек команды at
atd или atrun программа, которая разбирается с очередью заданий
batch эквивалентно at now, для нее создается специальная очередь. Ее особенность в том что эта очередь будет выполнена когда ОС мало загружена. 
Когда задача будет выполнена результат придет на электронную почту, смотреть командой mail (для обоих вариантов)


Периодические задания
Команда cron для периодических заданий
Команда crontab смотрит /etc/crontab каждую минуту, и смотрит не надо ли что-то выполнить
Что означают поля файла:
В какую минуту, в какой час, в какой день месяца, в какой месяц, в какой день недели должно быть запущено задание, от имени какого пользователя, какая команда должна выполняться
Все условия должны выполняться одновременно, кроме полей 3 и 5 – для них логическое или: те либо 15 числа либо в пятницу
Числа могут указываться через запятую, или * (любой), или диапазон (1-5), */5 каждую пять минут


Мониторинг работы процессов
Ps (процесс статус) какие процессы для данного терминала
Все параметры ключевые, поэтому минус можно не писать
Ключи бывают двух видов:
1) Информацию о каких процессах распечатывать
2) Какую информацию о процессах распечатывать

last –a для всех пользователей
Ps –x добавит процессы которые запускались не из терминала
Также хорошо бы знать lyj
Пид, управляющий терминал, текущее состояние процесса, сколько времени работает, какой командой был вызван (когда имя команды или имя файла не совпадает – имя команды выводится в скобочках)

Команда top показывает текущее состояние процессов, сколько вместиться на экране (обновляя каждые две секунды), те общее состояние ОС
Last pid – процесс запущенный перед top
Load Averages загрузка ЦП за последние 1, 5, 15 минут
Упорядочивание происходит по средней загрузку ЦП
Горячая клавиша h - подсказки

Команда sync сбрасывает кэш на диск принудительно, например если хотим резко вырубить питание. Однако этот сброс изменит кэш, поэтому нужно выполнить синк несколько раз

Что такое приоритет и привлекательность процесса:
Интерактивные и неинтерактивные задания
Интерактивые задания - нужно дать ЦП как можно быстрее, но квант времени поменьше
Нентерактивые - можно дать попозже, но квант побольше
Квант времени - это время через которое точно произойдет прерывание (таймер закончится)
Чем процесс стоит дальше в очереди, тем больший ему нужен квант. Это делается для того чтобы процессы получали примерно одинаковое время ЦП.
Со временем приоритет процесса постепенно уменьшается.

Когда процесс находится в очереди, чем меньше у него приоритет, тем быстрее он получит ЦП, приоритет – понятие динамическое, когда процесс прерывается в зависимости от того отработал он свой квант времени или нет, у него меняется приоритет. Приоритет процесса – атрибут, наследуется от родителя к ребенку. 
Привлекательность (nicevalue) - чем больше привлекательность, тем больше будет начальное значение приоритета процесса потомков. Тоже атрибут процесса, но не меняется со временем.
Привлекательность меняется от -20 до +20. 
nice -5 echo увеличить привлекательность на -5 по сравнению с родительским процессом (в данном случае шеллом).
Обычный пользователь может только увеличить привлекательность процессов. Уменьшать может только суперпользователь.
Nice – -5 (два минуса) увеличить на минус 5 может только суперпользователь.
renice (насколько изменить) (пид процесса)


Перенаправление ввода вывода 
Command <file перенаправили стандартный ввод
Command 3<infile 5>outfile
Если перед < ничего не стоит, подразумевается 0( стандартный ввод), если перед > ничего не стоит подразумевается 1( стандартный вывод)
Все перенаправления могут стоять в любом месте, тк перенаправления обрабатываются вначале
Command 2>&1 поток ошибок перенаправляем в потом стандартного вывода
<&3 теперь любое чтение из стандартного ввода есть чтение из потока 3
Любой процесс может открыть файл, тогда создается новые потоки ввода-вывода связывающие эти файлы
В директории proc можно посмотреть какой поток связывает файлы
Fstat или lsof для каждого процесса показывает какие потоки ввода-вывода открыты и с какими процессам они связаны
Command >file 2>&1 (обрабатывается строго в порядке написания) в файле окажется и стандартный вывод и ошибки

Амперсант в конце строки говорит выдать приглашение не дожидаясь выполнения команды
Command >file 2>file тогда файл будет открыт два раза, и ошибки будут писаться поверх стандартного вывода  
Command 2>&1 >file (ошибки окажутся в том месте где раньше был стандартный вывод, а вывод теперь будет с файл)
Command >>file перенаправить вывод но в конец файла, те после того что уже записано
Пример:
Error – сообщение об ошибке
echo Error >&2 перенаправить стандартную ошибку

Command <<file 
Sh <file Если в скрипте есть команда которая читает со стандартного ввода, то она будет читать из файла, с того момента, где закончил читать sh (те то что после этой команды)
Тк при наследовании потока ввода вывода, текущие позиции чтения и записи синхронизируются
Command1
Command2
Command3
Command4

Command5
Command6
Допустим команда 2 читает одну строчку, тогда она прочитает команду 3, и шелл проддолжит читать с команды 4
Это отличается от Sh file когда шелл прочитает все 7 команд
<<ffff 
Command1 <<EOF
Yes
EOF
Теперь comand1 имеет стандартный ввод pipe в который данные отправляет шелл, происходит это до того как шелл встретит EOF, после этого command1 перестает читать, шелл ждет завершения comand1  и продолжает работу шелл.
(те если мы не напишем << стандартным вводом comand1 будет терминал, и нам придется вручную написать yes. Если мы напишем << то сдандартным вводом comand1 будет pipe, данные в который отправляет шелл, у которого стандартный ввод это скрипт.
Те впринципе мы могли бы вместо Command1 <<EOF; yes; написать Command1 < file, причем в файле одно слово: yes



Функции в шелле
Func() функция определена
Тело функции – последовательность команд в {}
Printfirstarg() {
Echo $1
}
Напечатать первый аргумент
Если в функции написать exit весь скрипт завершиться
Return 0 завершит только функцию с кодом возврата 0
Printfirstarg x1 x2 x3 – запуск функции
ДЗ написать команду addpath (имя директории) которая добавляет в path новую директорию, если ее там еще нету
Addpath не может быть отдельным шелловским скриптом, эту команду надо встроить в шелл, поэтому addpath должен быть функцией
Те мы должны написать эту функцию в файл .profile
source (имя файла в котором функция); addpath (имя директории)
source тот же самый include и даю шеллу файл с функцией 
PATH=”$PATH:$1”

Команда source (или точка) работает аналогично include в си
. yyy те шелл будет читать дальше yyy а когда закончит, вернется к обычно стандартному вводу
Когда мы запускаем через точку (или source) нового процесса не создается, в отличие от sh
Ожидается что мы не будем портить .profile для этого мы должны написать 
. addpath те как бы мы подцепляем новый файл
Adpath directory и теперь добавляем новую директорию


Exec (команда с параметрами) заставляет выполнять команду в том же процессе, что и шелл
Exec echo hello 
Echo world 
Будет напечатано только hello 

Exec echo hello если это будет выполнять логин шелл то после команды будет завершен сеанс
Exec без параметров поменяет ввод-вывод которые указаны в командной строке

Команда set –x действует на текущий шелл (не знаю что делает)
Команда expr – это калькулятор, например 2 + 2, или 2 \* 2
X= `expr 1 + $x ` прибавляет к х один – причем число лучше писать число слева
X= `expr 0 + $a + $x `
Expr $x \> 1 сравнить
Вместо команды expr можно выполнять арифметические подстановки: x=$((x+1))

Команда env
Env x=5 command сделать переменную х переменной окружения только для одной команды
Export x=5 делает переменной окружения для всех процессов
x=5 command – слово env можно опускать


echo `souath ./` выводит путь к директории .



Регулярные выражения – шаблон применяемый к строке символов
Мы говорим что строка подходит под шаблон если в ней есть подстрока, такая что каждый символ подстроки соответствует символу шаблона
Символы в шаблонах: обычные (латинские буквы и цифры) и мета-символы (точка, ?)
Если регулярное выражение состоит из одного обычного символа, то соответствие если есть подстрока которая состоит из одного этого символа. (те если в строке есть этот символ)

Если R1 R2 регулярные выражения, то R1R2 тоже регулярное выражение. Такому выражения соответствует подстрока которую можно разбить на две части, первая часть соответствует R1 а вторая часть R2. Короче в строке должны подряд идти R1R2.
Аналогично для любой последовательности символов – если она является подстрокой, то строка подходит под шаблон
Метасимволы:
Точка: ей соответствует произвольный символ. Те a.b соответствует только строка из трех символов. 
[последовательность символов в квадратный скобках] – одни из символов в скобках
[a-e] можно писать интервал
Если мы хотим чтобы минус был одним из вариантов то минус писать в начале: [-ae]
[^a-e] любой из символов не входящих в набор
\c один символ совпадающий с ним, в независимости от того, обычный это символ или метасимвол, те a\.b соответствует только a.b
b* соответвует: пустая строка, b, bb, bbb, bbbb и так далее. Сама по себе * это не регулярное выражение.
ab* соответствует a, ab, abb, abbb…
\(abc\) соответствуют подстроки соответсвующие abc
\(abc\)* соответствует пустая строка, abc, abcabc,abcabcabc…
Якоря:
^ привязывает походящую подстроку к началу строки
$ если в конце шаблона, то подстрока должна находится в конце строки
ab?c соответствует ac и abc. (вопрос – значит этот символ может быть, а может не быть)


Расширенные регулярные выражения – несовместимы с обычными регулярными
Здесь пишут (R) а не \(R\)
R+ эквивалентно RR*
R1|R2 соответствуют подстроки соответствующие или 1 или 2


Команда grep – расширение fgrep (регулярное выражение) (файлы) 
Если один позиционный параметр то работает как фильтр
Чтобы показывалось из какого файла строка надо написать больше одного файла, чтобы добавить пустой файл
Возращает 0 если вывела хотя бы одну строку, иначе 1
-I игнорировать регистр
-v те строки которые не соответствуют шаблону
-e если регулярное выражение начинается с минуса, то чтобы минус правильно распознался перед этой строкой надо написать –е
-Е расширенные регулярные выражения
-f воспринимать шаблоны как обычные строчки (сделать аналогичной fgrep)
--line-buffered обычно grep сначала накапливает строки в буффере, и потом выводит все вместе, с этим же ключом вывод происходит сразу без буффера (отключает буфферизацию)
Эти ключи работают для fgrep и egrep



ed file редактирование файла прямо в скрипте
15 встать на строчку 15
p напечатать строчку
s/5/6 заменить 5 на 6 (s регулярное выражение, на что заменяем, опции замены)
3d удалить первую строчку
w записать изменения на диск, если мы изменили что-то перед выходом нужно сохранить
q выйти из ed
q! выйти без сохранения


sed если одни параметр – то фильтр, если несколько то обрабатывает файлы
sed команда файл – команда будет выполнена для всех строчек файла
Команда: указатель на строку, что сделать, параметры действия

Обции замены обрабатывается s
i игнорировать регистр
p напечатать изменения

Ключи обрабатываются sed
-n не печатать результат обработки


Команда
awk – развитие sed, целый язык программирования
awk программа на языке awk, список файлов

Программа на языке awk состоит из селектора и действие – селектор определяет строчку в файле
Селектор может быть регулярным выражением, условием (примерно как в си)
Если селектор отсутствует – то применяется ко всем строкам
Если для селектора отсутствует действие – значить просто распечатать строку
Действие всегда заключается в {}
awk ‘x>5{print x,y}’ Если х>5 распечатать x,y
Если два селектора разделены запятой, следовательно задан диапазон, те пока оба условия верны
Специальные селекторы:
BEGIN действия этих селекторов выполниться до обработки всех файлов
Когда мы начинаем использовать переменную, она сразу объявляется равно нулю или нулевой строке
END действия этих селекторов выполниться после обработки всех файлов
Слова разделяются пробелом и табуляцией
$5 – пятое слово в строке
$0 содержит всю строку целиком
NF – сколько слов в строке
NR –номер строки, которая сейчас обрабатывается
FILENAME – имя файла который сейчас обрабатывается
FS – аналог IFS в шелле, но в нем могут использоваться регулярные выражения (для чтения)
OFS – разделитель строк, который используется в операторе print (FS только для записи)
Пробел – операция соединения строк между собой те awk ‘{print x y}’ распечатает x y без разделителей
awk ‘{OFS=”:” print x,y}’ распечатает x y через разделитель двоеточие.
next перейти к следующей строке
В awk массив - это как хэш-таблица в си, те каждый элемент – это набор символов
If (index in array) есть ли в массиве значения для данного индекса
Не иметь значения, и иметь нулевое значение – разные вещи (если мы напишем print a[5] то так как мы обратились к 5му индеку, он проинициализируется нулем)
for (i-0;i<N;i++) {…} 
for (var in array) – var будет последовательно присвоены все значения массива – второй вид for


ДЗ 
1)Написать частотный словарь на awk – нужно посчитать сколько раз слово встретилось в этом файле, и посчитать общее число слов. Поделить количество данных слов на общее
Чтобы запустить программу awk -f
2) frame abc def должна заключить надпись в рамку из звездочек – это на sed, не должно быть прибавить 3 к длине строки


Псевдоустройства 
Для каждого устройства существует свой файл устройства. Однако есть файл устройств для которых не существует реального устройства.
/dev/null если мы будем читать, то будем всегда получать знак конца файла, если писать – данные будут пропадать
/dev/zero если будем читать то будем получать нулевые байты, если писать, то получим ошибку что устройство переполнено
/dev/random будем читать случайные данные 
/dev/urandom псевдо-случайные числа, но работает быстрее


tail –f file напечатает последние 10 строчек файла, и будет работать бесконечно долго, печатая  новые данные, которые появляющиеся в этом файле
ls –h вывести в удобном для человека виде
ls –t сортировать по времени последнего изменения файлов
EDITOR=mcedit crontab –e редактировать пользовательские периодические задания причем это сделать в редакторе mcedit. Для пользовательского кронтаба нету имени пользователся, те в 6м поле будет идти исполняемый файл
Crontab –l посмотреть задания для этого пользователя


Mknod (имя файла устройств) (блочное или символное) (главный и вспомогательный номер) (кому принадлежит)


Команды показывающий информацию о пользователях сервера
Команда who показывает  информацию о текущих пользователях терминала
Who am i
Команда w аналогично показывает информацию о пользователях, но немного другая инфа
Finger
Finger mahimh   
.plan файл с информацией о моих планах, который доступен другим пользователям
Last история посещений пользователями сервера


Файлы utmp wtmp (команда locate показывает местонахождение файлов)
Utmp база данных о текущих пользователях
Wtmp хранит историю посещений


Atrm удалить задания из пакетных заданий (те отложенных)

#! Говорит что этот файл нужно выполнять определенным шеллом (или например питоном)
Если не начинается с #! Будет использоваться шелл по умолчанию























 




 







































 












































